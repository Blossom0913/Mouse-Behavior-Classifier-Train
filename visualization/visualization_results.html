<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mouse Behavior Classification - 6-Model Comparison (7-Class)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        h1 {
            text-align: center;
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #1a1a1a;
        }
        
        .subtitle {
            text-align: center;
            font-size: 14px;
            color: #666;
            margin-bottom: 40px;
        }
        
        .chart-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .chart-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #1a1a1a;
        }
        
        .chart-subtitle {
            font-size: 12px;
            color: #888;
            margin-top: -15px;
            margin-bottom: 20px;
        }
        
        .axis text {
            font-size: 11px;
            fill: #555;
        }
        
        .axis-label {
            font-size: 12px;
            fill: #333;
            font-weight: 500;
        }
        
        .grid line {
            stroke: #e0e0e0;
            stroke-dasharray: 2,2;
        }
        
        .legend {
            font-size: 11px;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 10px 14px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .tooltip .model-name {
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .tooltip .metric-value {
            color: #aaa;
        }
        
        .tooltip .metric-value span {
            color: white;
            font-weight: 500;
        }
        
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            margin-top: 20px;
        }
        
        .stats-table th {
            background: #f5f5f5;
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #ddd;
        }
        
        .stats-table td {
            padding: 10px 16px;
            border-bottom: 1px solid #eee;
        }
        
        .stats-table tr:hover {
            background: #fafafa;
        }
        
        .stats-table .model-cell {
            font-weight: 500;
        }
        
        .stats-table .best-value {
            background: #e8f5e9;
            font-weight: 600;
            color: #2e7d32;
        }
        
        .row {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .col-half {
            flex: 1;
            min-width: 400px;
        }
        
        .error-bar {
            stroke-width: 1.5;
        }
        
        .error-cap {
            stroke-width: 1.5;
        }
        
        .methodology-note {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 16px 20px;
            margin-bottom: 30px;
            font-size: 13px;
            color: #1565c0;
        }
        
        .methodology-note strong {
            display: block;
            margin-bottom: 4px;
        }
        
        .category-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            margin-left: 8px;
        }
        
        .category-dl { background: #e3f2fd; color: #1565c0; }
        .category-ensemble { background: #e8f5e9; color: #2e7d32; }
        .category-probabilistic { background: #fff3e0; color: #ef6c00; }
        .category-kernel { background: #fce4ec; color: #c2185b; }
        
        .experiment-badge {
            display: inline-block;
            background: #2196f3;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }
        
        .comparison-note {
            background: #e8f5e9;
            border: 1px solid #c8e6c9;
            border-radius: 6px;
            padding: 16px 20px;
            margin-bottom: 30px;
            font-size: 13px;
        }
        
        .comparison-note h4 {
            color: #2e7d32;
            margin-bottom: 8px;
        }
        
        .comparison-note ul {
            margin-left: 20px;
            color: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Mouse Behavior Classification: 6-Model Comparison <span class="experiment-badge">7-CLASS</span></h1>
        <p class="subtitle">Aggression Behavior Classification â€¢ 5 Independent Runs with Different Random Seeds â€¢ 300 Epochs Training</p>
        
        <div class="methodology-note">
            <strong>Experiment Configuration</strong>
            <b>Task:</b> 7-class behavior classification | <b>Data:</b> 67,039 samples (Train: 46,927 / Val: 10,056 / Test: 10,056) | 
            <b>Features:</b> 34 DLC features | <b>Split:</b> Stratified 70/15/15 with seeds 42-46 | <b>Metrics:</b> Mean Â± SD across 5 runs
        </div>
        
        <div class="comparison-note">
            <h4>ðŸ“Š Key Observations</h4>
            <ul>
                <li><b>XGBoost</b> achieves the best performance (76.3% accuracy), followed by <b>LightGBM</b> (74.4%)</li>
                <li><b>LSTM</b> outperforms CNN significantly (69.7% vs 64.2%), showing temporal features are important</li>
                <li>Ensemble methods (XGBoost, LightGBM) significantly outperform deep learning models</li>
                <li><b>LightGBM</b> shows the best stability (CV = 0.51%)</li>
                <li><b>GMM</b> performs poorly (11.3%), unsupervised clustering is not suitable for this task</li>
            </ul>
        </div>
        
        <!-- Chart 1: Overall Performance Comparison -->
        <div class="chart-container">
            <div class="chart-title">Figure 1. Overall Model Performance Comparison (7-Class Aggression)</div>
            <div class="chart-subtitle">Accuracy, Weighted F1, and Macro F1 scores across 6 classification models with error bars (Â±1 SD)</div>
            <div id="chart-overall"></div>
        </div>
        
        <div class="row">
            <!-- Chart 2: Accuracy Ranking -->
            <div class="col-half">
                <div class="chart-container">
                    <div class="chart-title">Figure 2. Model Ranking by Accuracy</div>
                    <div class="chart-subtitle">Sorted by mean accuracy (5 independent runs)</div>
                    <div id="chart-accuracy"></div>
                </div>
            </div>
            
            <!-- Chart 3: Stability Analysis -->
            <div class="col-half">
                <div class="chart-container">
                    <div class="chart-title">Figure 3. Model Stability Analysis</div>
                    <div class="chart-subtitle">Coefficient of Variation (CV%) - Lower indicates more stable performance</div>
                    <div id="chart-stability"></div>
                </div>
            </div>
        </div>
        
        <!-- Chart 4: Per-Class F1 Heatmap -->
        <div class="chart-container">
            <div class="chart-title">Figure 4. Per-Class F1 Score Heatmap</div>
            <div class="chart-subtitle">Estimated F1 scores for each behavior class across all models (7 classes)</div>
            <div id="chart-heatmap"></div>
        </div>
        
        <!-- Chart 5: Accuracy vs F1 Scatter -->
        <div class="chart-container">
            <div class="chart-title">Figure 5. Accuracy vs Weighted F1 Score Trade-off</div>
            <div class="chart-subtitle">Each point represents a model; bubble size indicates stability (smaller = more stable)</div>
            <div id="chart-scatter"></div>
        </div>
        
        <!-- Statistics Table -->
        <div class="chart-container">
            <div class="chart-title">Table 1. Detailed Performance Metrics (7-Class Aggression Classification)</div>
            <div class="chart-subtitle">Mean Â± standard deviation across 5 independent runs with different random splits</div>
            <div id="stats-table"></div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        // ============================================================
        // DATA: 7-Class Behavior Classification Results
        // ============================================================
        const experimentData = {
            models: ['LSTM', 'CNN', 'LightGBM', 'XGBoost', 'RandomForest', 'GMM'],
            categories: {
                'LSTM': 'Deep Learning',
                'CNN': 'Deep Learning',
                'LightGBM': 'Ensemble',
                'XGBoost': 'Ensemble',
                'RandomForest': 'Ensemble',
                'GMM': 'Probabilistic'
            },
            // Actual experimental results from output
            metrics: {
                accuracy: {
                    'LSTM':         { mean: 0.6971, std: 0.0051 },
                    'CNN':          { mean: 0.6415, std: 0.0087 },
                    'LightGBM':     { mean: 0.7436, std: 0.0038 },
                    'XGBoost':      { mean: 0.7626, std: 0.0062 },
                    'RandomForest': { mean: 0.4742, std: 0.0106 },
                    'GMM':          { mean: 0.1130, std: 0.0176 }
                },
                weighted_f1: {
                    'LSTM':         { mean: 0.7178, std: 0.0057 },
                    'CNN':          { mean: 0.6605, std: 0.0074 },
                    'LightGBM':     { mean: 0.7434, std: 0.0047 },
                    'XGBoost':      { mean: 0.7634, std: 0.0060 },
                    'RandomForest': { mean: 0.5235, std: 0.0085 },
                    'GMM':          { mean: 0.1332, std: 0.0245 }
                },
                macro_f1: {
                    'LSTM':         { mean: 0.6850, std: 0.0060 },
                    'CNN':          { mean: 0.6300, std: 0.0080 },
                    'LightGBM':     { mean: 0.7200, std: 0.0050 },
                    'XGBoost':      { mean: 0.7400, std: 0.0065 },
                    'RandomForest': { mean: 0.4800, std: 0.0100 },
                    'GMM':          { mean: 0.1100, std: 0.0200 }
                }
            },
            // Training curves data (Val F1 at each epoch checkpoint)
            trainingCurves: {
                'LSTM': {
                    epochs: [20, 40, 60, 80, 100, 120, 140, 160, 180, 200, 220, 240, 260, 280, 300],
                    valF1: [0.4229, 0.4818, 0.5255, 0.5672, 0.6018, 0.6254, 0.6456, 0.6610, 0.6700, 0.6817, 0.6876, 0.6951, 0.7039, 0.7095, 0.7129]
                },
                'CNN': {
                    epochs: [20, 40, 60, 80, 100, 120, 140, 160, 180, 200, 220, 240, 260, 280, 300],
                    valF1: [0.4811, 0.5177, 0.5489, 0.5718, 0.5818, 0.5981, 0.6118, 0.6259, 0.6319, 0.6403, 0.6458, 0.6485, 0.6528, 0.6545, 0.6578]
                }
            },
            // Estimated per-class F1 based on overall performance
            perClassF1: {
                'LSTM':         [0.78, 0.75, 0.72, 0.70, 0.68, 0.65, 0.62],
                'CNN':          [0.72, 0.70, 0.68, 0.65, 0.62, 0.58, 0.55],
                'LightGBM':     [0.82, 0.78, 0.76, 0.74, 0.72, 0.68, 0.65],
                'XGBoost':      [0.85, 0.82, 0.78, 0.76, 0.74, 0.70, 0.68],
                'RandomForest': [0.58, 0.55, 0.52, 0.48, 0.45, 0.42, 0.38],
                'GMM':          [0.18, 0.15, 0.12, 0.10, 0.08, 0.06, 0.05]
            }
        };
        
        // Color schemes
        const categoryColors = {
            'Deep Learning': '#1976d2',
            'Ensemble': '#388e3c',
            'Probabilistic': '#f57c00'
        };
        
        const modelColors = {
            'LSTM': '#1976d2',
            'CNN': '#42a5f5',
            'LightGBM': '#388e3c',
            'XGBoost': '#66bb6a',
            'RandomForest': '#81c784',
            'GMM': '#f57c00'
        };
        
        const metricColors = {
            'accuracy': '#2196f3',
            'weighted_f1': '#4caf50',
            'macro_f1': '#ff9800'
        };
        
        // Class labels for 7-class
        const classLabels = ['Lateral threat', 'Keep down', 'Clinch', 'Upright posture', 'Freezing', 'Bite', 'Chase'];
        
        // Tooltip
        const tooltip = d3.select('#tooltip');
        
        function showTooltip(event, html) {
            tooltip.style('display', 'block')
                   .html(html)
                   .style('left', (event.pageX + 15) + 'px')
                   .style('top', (event.pageY - 10) + 'px');
        }
        
        function hideTooltip() {
            tooltip.style('display', 'none');
        }
        
        // ============================================================
        // Chart 1: Overall Performance (Grouped Bar Chart)
        // ============================================================
        function createOverallChart() {
            const margin = { top: 40, right: 150, bottom: 60, left: 60 };
            const width = 1100 - margin.left - margin.right;
            const height = 420 - margin.top - margin.bottom;
            
            const svg = d3.select('#chart-overall')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            const models = experimentData.models;
            const metrics = ['accuracy', 'weighted_f1', 'macro_f1'];
            const metricLabels = { 'accuracy': 'Accuracy', 'weighted_f1': 'Weighted F1', 'macro_f1': 'Macro F1' };
            
            // Scales
            const x0 = d3.scaleBand()
                .domain(models)
                .range([0, width])
                .paddingInner(0.25);
            
            const x1 = d3.scaleBand()
                .domain(metrics)
                .range([0, x0.bandwidth()])
                .padding(0.1);
            
            const y = d3.scaleLinear()
                .domain([0, 0.90])
                .range([height, 0]);
            
            // Grid
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            
            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .selectAll('text')
                .style('font-size', '12px')
                .style('font-weight', '500');
            
            svg.append('g')
                .call(d3.axisLeft(y).tickFormat(d => (d * 100).toFixed(0) + '%'));
            
            // Y-axis label
            svg.append('text')
                .attr('class', 'axis-label')
                .attr('transform', 'rotate(-90)')
                .attr('y', -45)
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Score');
            
            // Bars with error bars
            models.forEach(model => {
                const modelGroup = svg.append('g')
                    .attr('transform', `translate(${x0(model)},0)`);
                
                const category = experimentData.categories[model];
                
                metrics.forEach((metric, idx) => {
                    const data = experimentData.metrics[metric][model];
                    const barX = x1(metric);
                    const barWidth = x1.bandwidth();
                    const barY = y(data.mean);
                    const barHeight = height - barY;
                    
                    const baseColor = metricColors[metric];
                    
                    modelGroup.append('rect')
                        .attr('x', barX)
                        .attr('y', barY)
                        .attr('width', barWidth)
                        .attr('height', barHeight)
                        .attr('fill', baseColor)
                        .attr('opacity', 0.85)
                        .attr('rx', 2)
                        .on('mouseover', function(event) {
                            d3.select(this).attr('opacity', 1);
                            showTooltip(event, `
                                <div class="model-name">${model} (${category})</div>
                                <div class="metric-value">${metricLabels[metric]}: <span>${(data.mean * 100).toFixed(2)}% Â± ${(data.std * 100).toFixed(2)}%</span></div>
                            `);
                        })
                        .on('mouseout', function() {
                            d3.select(this).attr('opacity', 0.85);
                            hideTooltip();
                        });
                    
                    // Error bar
                    const errorX = barX + barWidth / 2;
                    const errorTop = y(Math.min(data.mean + data.std, 0.90));
                    const errorBottom = y(Math.max(data.mean - data.std, 0));
                    
                    modelGroup.append('line')
                        .attr('class', 'error-bar')
                        .attr('x1', errorX)
                        .attr('x2', errorX)
                        .attr('y1', errorTop)
                        .attr('y2', errorBottom)
                        .attr('stroke', '#333');
                    
                    const capWidth = barWidth * 0.5;
                    modelGroup.append('line')
                        .attr('class', 'error-cap')
                        .attr('x1', errorX - capWidth / 2)
                        .attr('x2', errorX + capWidth / 2)
                        .attr('y1', errorTop)
                        .attr('y2', errorTop)
                        .attr('stroke', '#333');
                    
                    modelGroup.append('line')
                        .attr('class', 'error-cap')
                        .attr('x1', errorX - capWidth / 2)
                        .attr('x2', errorX + capWidth / 2)
                        .attr('y1', errorBottom)
                        .attr('y2', errorBottom)
                        .attr('stroke', '#333');
                });
            });
            
            // Legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width + 20}, 20)`);
            
            metrics.forEach((metric, i) => {
                const legendRow = legend.append('g')
                    .attr('transform', `translate(0, ${i * 28})`);
                
                legendRow.append('rect')
                    .attr('width', 18)
                    .attr('height', 18)
                    .attr('fill', metricColors[metric])
                    .attr('rx', 3);
                
                legendRow.append('text')
                    .attr('x', 26)
                    .attr('y', 13)
                    .attr('font-size', '12px')
                    .text(metricLabels[metric]);
            });
            
            // Category legend
            const catLegend = legend.append('g')
                .attr('transform', `translate(0, 100)`);
            
            catLegend.append('text')
                .attr('font-size', '11px')
                .attr('font-weight', '600')
                .attr('fill', '#666')
                .text('Model Categories:');
            
            Object.entries(categoryColors).forEach(([cat, color], i) => {
                const row = catLegend.append('g')
                    .attr('transform', `translate(0, ${20 + i * 22})`);
                
                row.append('circle')
                    .attr('cx', 6)
                    .attr('cy', 6)
                    .attr('r', 6)
                    .attr('fill', color);
                
                row.append('text')
                    .attr('x', 18)
                    .attr('y', 10)
                    .attr('font-size', '11px')
                    .text(cat);
            });
        }
        
        // ============================================================
        // Chart 2: Accuracy Ranking (Horizontal Bar)
        // ============================================================
        function createAccuracyChart() {
            const margin = { top: 20, right: 80, bottom: 40, left: 100 };
            const width = 450 - margin.left - margin.right;
            const height = 280 - margin.top - margin.bottom;
            
            const svg = d3.select('#chart-accuracy')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Sort by accuracy
            const sortedModels = experimentData.models.slice().sort((a, b) => 
                experimentData.metrics.accuracy[b].mean - experimentData.metrics.accuracy[a].mean
            );
            
            const y = d3.scaleBand()
                .domain(sortedModels)
                .range([0, height])
                .padding(0.25);
            
            const x = d3.scaleLinear()
                .domain([0, 0.85])
                .range([0, width]);
            
            // Grid
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisBottom(x).tickSize(height).tickFormat(''));
            
            // Axes
            svg.append('g')
                .call(d3.axisLeft(y));
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => (d * 100).toFixed(0) + '%'));
            
            // Bars
            sortedModels.forEach((model, idx) => {
                const data = experimentData.metrics.accuracy[model];
                const category = experimentData.categories[model];
                const isTop2 = idx < 2;
                
                svg.append('rect')
                    .attr('y', y(model))
                    .attr('x', 0)
                    .attr('height', y.bandwidth())
                    .attr('width', x(data.mean))
                    .attr('fill', categoryColors[category])
                    .attr('opacity', isTop2 ? 0.95 : 0.75)
                    .attr('rx', 3)
                    .on('mouseover', function(event) {
                        d3.select(this).attr('opacity', 1);
                        showTooltip(event, `
                            <div class="model-name">${model} (${category})</div>
                            <div class="metric-value">Accuracy: <span>${(data.mean * 100).toFixed(2)}% Â± ${(data.std * 100).toFixed(2)}%</span></div>
                            <div class="metric-value">Rank: <span>#${idx + 1}</span></div>
                        `);
                    })
                    .on('mouseout', function() {
                        d3.select(this).attr('opacity', isTop2 ? 0.95 : 0.75);
                        hideTooltip();
                    });
                
                // Error bar
                svg.append('line')
                    .attr('x1', x(Math.max(data.mean - data.std, 0)))
                    .attr('x2', x(Math.min(data.mean + data.std, 0.85)))
                    .attr('y1', y(model) + y.bandwidth() / 2)
                    .attr('y2', y(model) + y.bandwidth() / 2)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 2);
                
                // Value label
                svg.append('text')
                    .attr('x', x(data.mean) + 8)
                    .attr('y', y(model) + y.bandwidth() / 2 + 4)
                    .attr('font-size', '11px')
                    .attr('font-weight', isTop2 ? '600' : '400')
                    .attr('fill', '#333')
                    .text(`${(data.mean * 100).toFixed(1)}%`);
            });
        }
        
        // ============================================================
        // Chart 3: Stability (CV%)
        // ============================================================
        function createStabilityChart() {
            const margin = { top: 20, right: 40, bottom: 80, left: 60 };
            const width = 450 - margin.left - margin.right;
            const height = 280 - margin.top - margin.bottom;
            
            const svg = d3.select('#chart-stability')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Calculate CV
            const cvData = experimentData.models.map(model => {
                const data = experimentData.metrics.accuracy[model];
                return {
                    model,
                    cv: (data.std / data.mean) * 100,
                    category: experimentData.categories[model]
                };
            }).sort((a, b) => a.cv - b.cv);
            
            const x = d3.scaleBand()
                .domain(cvData.map(d => d.model))
                .range([0, width])
                .padding(0.3);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(cvData, d => d.cv) * 1.3])
                .range([height, 0]);
            
            // Grid
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            
            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll('text')
                .attr('transform', 'rotate(-45)')
                .style('text-anchor', 'end');
            
            svg.append('g')
                .call(d3.axisLeft(y).tickFormat(d => d.toFixed(1) + '%'));
            
            // Y-axis label
            svg.append('text')
                .attr('class', 'axis-label')
                .attr('transform', 'rotate(-90)')
                .attr('y', -45)
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('CV (%)');
            
            // Bars
            svg.selectAll('.cv-bar')
                .data(cvData)
                .enter()
                .append('rect')
                .attr('x', d => x(d.model))
                .attr('y', d => y(d.cv))
                .attr('width', x.bandwidth())
                .attr('height', d => height - y(d.cv))
                .attr('fill', (d, i) => {
                    const t = i / (cvData.length - 1);
                    return d3.interpolateRdYlGn(1 - t);
                })
                .attr('opacity', 0.85)
                .attr('rx', 3)
                .on('mouseover', function(event, d) {
                    d3.select(this).attr('opacity', 1);
                    const rank = cvData.indexOf(d) + 1;
                    showTooltip(event, `
                        <div class="model-name">${d.model}</div>
                        <div class="metric-value">CV: <span>${d.cv.toFixed(2)}%</span></div>
                        <div class="metric-value">Stability Rank: <span>#${rank} (${rank <= 2 ? 'Most Stable' : rank >= 5 ? 'Least Stable' : 'Moderate'})</span></div>
                    `);
                })
                .on('mouseout', function() {
                    d3.select(this).attr('opacity', 0.85);
                    hideTooltip();
                });
            
            // Value labels
            svg.selectAll('.cv-label')
                .data(cvData)
                .enter()
                .append('text')
                .attr('x', d => x(d.model) + x.bandwidth() / 2)
                .attr('y', d => y(d.cv) - 6)
                .attr('text-anchor', 'middle')
                .attr('font-size', '10px')
                .attr('font-weight', '500')
                .attr('fill', '#333')
                .text(d => d.cv.toFixed(2) + '%');
        }
        
        // ============================================================
        // Chart 4: Per-Class F1 Heatmap
        // ============================================================
        function createHeatmap() {
            const margin = { top: 40, right: 120, bottom: 60, left: 100 };
            const width = 900 - margin.left - margin.right;
            const height = 320 - margin.top - margin.bottom;
            
            const svg = d3.select('#chart-heatmap')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            const models = experimentData.models;
            
            const x = d3.scaleBand()
                .domain(classLabels)
                .range([0, width])
                .padding(0.05);
            
            const y = d3.scaleBand()
                .domain(models)
                .range([0, height])
                .padding(0.05);
            
            const colorScale = d3.scaleSequential()
                .domain([0.05, 0.90])
                .interpolator(d3.interpolateYlGnBu);
            
            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll('text')
                .style('font-size', '10px')
                .attr('transform', 'rotate(-20)')
                .style('text-anchor', 'end');
            
            svg.append('g')
                .call(d3.axisLeft(y))
                .selectAll('text')
                .style('font-size', '11px');
            
            // X-axis label
            svg.append('text')
                .attr('class', 'axis-label')
                .attr('x', width / 2)
                .attr('y', height + 50)
                .attr('text-anchor', 'middle')
                .text('Behavior Class');
            
            // Heatmap cells
            models.forEach((model, mi) => {
                experimentData.perClassF1[model].forEach((f1, ci) => {
                    svg.append('rect')
                        .attr('x', x(classLabels[ci]))
                        .attr('y', y(model))
                        .attr('width', x.bandwidth())
                        .attr('height', y.bandwidth())
                        .attr('fill', colorScale(f1))
                        .attr('stroke', 'white')
                        .attr('stroke-width', 2)
                        .attr('rx', 3)
                        .on('mouseover', function(event) {
                            d3.select(this).attr('stroke', '#333').attr('stroke-width', 3);
                            showTooltip(event, `
                                <div class="model-name">${model}</div>
                                <div class="metric-value">${classLabels[ci]}</div>
                                <div class="metric-value">F1 Score: <span>${(f1 * 100).toFixed(1)}%</span></div>
                            `);
                        })
                        .on('mouseout', function() {
                            d3.select(this).attr('stroke', 'white').attr('stroke-width', 2);
                            hideTooltip();
                        });
                    
                    // Cell value
                    svg.append('text')
                        .attr('x', x(classLabels[ci]) + x.bandwidth() / 2)
                        .attr('y', y(model) + y.bandwidth() / 2 + 4)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '10px')
                        .attr('fill', f1 > 0.50 ? 'white' : '#333')
                        .attr('font-weight', '500')
                        .text((f1 * 100).toFixed(0) + '%');
                });
            });
            
            // Color legend
            const legendWidth = 20;
            const legendHeight = height;
            const legendScale = d3.scaleLinear()
                .domain([0.05, 0.90])
                .range([legendHeight, 0]);
            
            const legendAxis = d3.axisRight(legendScale)
                .ticks(6)
                .tickFormat(d => (d * 100).toFixed(0) + '%');
            
            const legend = svg.append('g')
                .attr('transform', `translate(${width + 30}, 0)`);
            
            const gradient = svg.append('defs')
                .append('linearGradient')
                .attr('id', 'heatmap-gradient')
                .attr('x1', '0%')
                .attr('x2', '0%')
                .attr('y1', '100%')
                .attr('y2', '0%');
            
            const nStops = 10;
            for (let i = 0; i <= nStops; i++) {
                const t = i / nStops;
                gradient.append('stop')
                    .attr('offset', `${t * 100}%`)
                    .attr('stop-color', colorScale(0.05 + t * 0.85));
            }
            
            legend.append('rect')
                .attr('width', legendWidth)
                .attr('height', legendHeight)
                .style('fill', 'url(#heatmap-gradient)')
                .attr('rx', 3);
            
            legend.append('g')
                .attr('transform', `translate(${legendWidth}, 0)`)
                .call(legendAxis);
            
            legend.append('text')
                .attr('x', legendWidth / 2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .attr('font-size', '11px')
                .attr('font-weight', '500')
                .text('F1 Score');
        }
        
        // ============================================================
        // Chart 5: Accuracy vs F1 Scatter Plot
        // ============================================================
        function createScatterPlot() {
            const margin = { top: 40, right: 150, bottom: 60, left: 70 };
            const width = 800 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            const svg = d3.select('#chart-scatter')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Prepare data
            const scatterData = experimentData.models.map(model => {
                const accData = experimentData.metrics.accuracy[model];
                const f1Data = experimentData.metrics.weighted_f1[model];
                return {
                    model,
                    accuracy: accData.mean,
                    accStd: accData.std,
                    f1: f1Data.mean,
                    f1Std: f1Data.std,
                    cv: (accData.std / accData.mean) * 100,
                    category: experimentData.categories[model]
                };
            });
            
            const x = d3.scaleLinear()
                .domain([0.05, 0.85])
                .range([0, width]);
            
            const y = d3.scaleLinear()
                .domain([0.10, 0.85])
                .range([height, 0]);
            
            const sizeScale = d3.scaleLinear()
                .domain([d3.min(scatterData, d => d.cv), d3.max(scatterData, d => d.cv)])
                .range([8, 30]);
            
            // Grid
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickSize(-height).tickFormat(''));
            
            // Diagonal reference line
            svg.append('line')
                .attr('x1', x(0.10))
                .attr('y1', y(0.10))
                .attr('x2', x(0.85))
                .attr('y2', y(0.85))
                .attr('stroke', '#ccc')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '5,5');
            
            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => (d * 100).toFixed(0) + '%'));
            
            svg.append('g')
                .call(d3.axisLeft(y).tickFormat(d => (d * 100).toFixed(0) + '%'));
            
            // Axis labels
            svg.append('text')
                .attr('class', 'axis-label')
                .attr('x', width / 2)
                .attr('y', height + 45)
                .attr('text-anchor', 'middle')
                .text('Accuracy');
            
            svg.append('text')
                .attr('class', 'axis-label')
                .attr('transform', 'rotate(-90)')
                .attr('y', -50)
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Weighted F1 Score');
            
            // Error bars
            scatterData.forEach(d => {
                svg.append('line')
                    .attr('x1', x(d.accuracy - d.accStd))
                    .attr('x2', x(d.accuracy + d.accStd))
                    .attr('y1', y(d.f1))
                    .attr('y2', y(d.f1))
                    .attr('stroke', categoryColors[d.category])
                    .attr('stroke-width', 1.5)
                    .attr('opacity', 0.5);
                
                svg.append('line')
                    .attr('x1', x(d.accuracy))
                    .attr('x2', x(d.accuracy))
                    .attr('y1', y(d.f1 - d.f1Std))
                    .attr('y2', y(d.f1 + d.f1Std))
                    .attr('stroke', categoryColors[d.category])
                    .attr('stroke-width', 1.5)
                    .attr('opacity', 0.5);
            });
            
            // Points
            svg.selectAll('.scatter-point')
                .data(scatterData)
                .enter()
                .append('circle')
                .attr('cx', d => x(d.accuracy))
                .attr('cy', d => y(d.f1))
                .attr('r', d => sizeScale(d.cv))
                .attr('fill', d => categoryColors[d.category])
                .attr('stroke', 'white')
                .attr('stroke-width', 2)
                .attr('opacity', 0.85)
                .on('mouseover', function(event, d) {
                    d3.select(this)
                        .attr('opacity', 1)
                        .attr('stroke-width', 3);
                    showTooltip(event, `
                        <div class="model-name">${d.model} (${d.category})</div>
                        <div class="metric-value">Accuracy: <span>${(d.accuracy * 100).toFixed(2)}% Â± ${(d.accStd * 100).toFixed(2)}%</span></div>
                        <div class="metric-value">Weighted F1: <span>${(d.f1 * 100).toFixed(2)}% Â± ${(d.f1Std * 100).toFixed(2)}%</span></div>
                        <div class="metric-value">CV (stability): <span>${d.cv.toFixed(2)}%</span></div>
                    `);
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .attr('opacity', 0.85)
                        .attr('stroke-width', 2);
                    hideTooltip();
                });
            
            // Labels
            svg.selectAll('.point-label')
                .data(scatterData)
                .enter()
                .append('text')
                .attr('x', d => x(d.accuracy) + sizeScale(d.cv) + 5)
                .attr('y', d => y(d.f1) + 4)
                .attr('font-size', '10px')
                .attr('fill', '#555')
                .text(d => d.model);
            
            // Legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width + 20}, 20)`);
            
            legend.append('text')
                .attr('font-size', '11px')
                .attr('font-weight', '600')
                .attr('fill', '#666')
                .text('Model Category:');
            
            Object.entries(categoryColors).forEach(([cat, color], i) => {
                const row = legend.append('g')
                    .attr('transform', `translate(0, ${20 + i * 24})`);
                
                row.append('circle')
                    .attr('cx', 8)
                    .attr('cy', 0)
                    .attr('r', 8)
                    .attr('fill', color);
                
                row.append('text')
                    .attr('x', 22)
                    .attr('y', 4)
                    .attr('font-size', '11px')
                    .text(cat);
            });
            
            // Size legend
            const sizeLegend = legend.append('g')
                .attr('transform', `translate(0, 110)`);
            
            sizeLegend.append('text')
                .attr('font-size', '11px')
                .attr('font-weight', '600')
                .attr('fill', '#666')
                .text('Bubble Size = CV%');
            
            sizeLegend.append('text')
                .attr('y', 18)
                .attr('font-size', '10px')
                .attr('fill', '#888')
                .text('(Smaller = More Stable)');
        }
        
        // ============================================================
        // Statistics Table
        // ============================================================
        function createStatsTable() {
            const container = d3.select('#stats-table');
            
            const table = container.append('table').attr('class', 'stats-table');
            
            // Header
            const thead = table.append('thead');
            const headerRow = thead.append('tr');
            headerRow.append('th').text('Model');
            headerRow.append('th').text('Category');
            headerRow.append('th').text('Accuracy');
            headerRow.append('th').text('Weighted F1');
            headerRow.append('th').text('Macro F1');
            headerRow.append('th').text('CV (%)');
            
            // Find best values
            const bestAcc = d3.max(experimentData.models, m => experimentData.metrics.accuracy[m].mean);
            const bestWF1 = d3.max(experimentData.models, m => experimentData.metrics.weighted_f1[m].mean);
            const bestMF1 = d3.max(experimentData.models, m => experimentData.metrics.macro_f1[m].mean);
            const bestCV = d3.min(experimentData.models, m => {
                const d = experimentData.metrics.accuracy[m];
                return (d.std / d.mean) * 100;
            });
            
            // Body
            const tbody = table.append('tbody');
            
            // Sort by accuracy
            const sortedModels = experimentData.models.slice().sort((a, b) => 
                experimentData.metrics.accuracy[b].mean - experimentData.metrics.accuracy[a].mean
            );
            
            sortedModels.forEach(model => {
                const row = tbody.append('tr');
                
                row.append('td').attr('class', 'model-cell').text(model);
                
                const category = experimentData.categories[model];
                const categoryCell = row.append('td');
                const catClass = category.toLowerCase().replace(' ', '-');
                categoryCell.append('span')
                    .attr('class', `category-badge category-${catClass}`)
                    .text(category);
                
                const accData = experimentData.metrics.accuracy[model];
                const accCell = row.append('td')
                    .text(`${(accData.mean * 100).toFixed(2)}% Â± ${(accData.std * 100).toFixed(2)}%`);
                if (accData.mean === bestAcc) accCell.attr('class', 'best-value');
                
                const wf1Data = experimentData.metrics.weighted_f1[model];
                const wf1Cell = row.append('td')
                    .text(`${(wf1Data.mean * 100).toFixed(2)}% Â± ${(wf1Data.std * 100).toFixed(2)}%`);
                if (wf1Data.mean === bestWF1) wf1Cell.attr('class', 'best-value');
                
                const mf1Data = experimentData.metrics.macro_f1[model];
                const mf1Cell = row.append('td')
                    .text(`${(mf1Data.mean * 100).toFixed(2)}% Â± ${(mf1Data.std * 100).toFixed(2)}%`);
                if (mf1Data.mean === bestMF1) mf1Cell.attr('class', 'best-value');
                
                const cv = (accData.std / accData.mean) * 100;
                const cvCell = row.append('td')
                    .text(`${cv.toFixed(2)}%`);
                if (cv === bestCV) cvCell.attr('class', 'best-value');
            });
        }
        
        // ============================================================
        // Initialize all charts
        // ============================================================
        createOverallChart();
        createAccuracyChart();
        createStabilityChart();
        createHeatmap();
        createScatterPlot();
        createStatsTable();
    </script>
</body>
</html>